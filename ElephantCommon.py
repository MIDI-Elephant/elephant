from enum import Enum

#
# Some configuration values
#

#
# The following are the events generated by
# button presses.
#
E_PLAY_PAUSE_BUTTON='E_PlayPauseButton'
E_RECORD_BUTTON='E_RecordButton'
E_STOP_BUTTON='E_StopButton'
E_BACK_BUTTON='E_BackButton'
E_FORWARD_BUTTON='E_NextButton'
E_AUTO_RECORD_BUTTON='E_AutoRecordButton'

# 
# The following events are generated by internal code
#
E_RECORDING_SAVED='E_RecordingSaved'
E_END_OF_FILE='E_EndOfFile'
E_AUTO_NEXT='E_AutoNext'
E_NO_FILE='E_NoFile'
E_LAST_FILE='E_LastFile'
E_FIRST_FILE='E_FirstFile'
E_PREVIOUS_FILE='E_PreviousFile'
E_NEXT_FILE='E_NextFile'
E_SKIP_FORWARD='E_SkipForward'
E_SKIP_BACK='E_SkipBack'
E_SEEK_FORWARD='E_SeekForward'
E_SEEK_FORWARD_RELEASED='E_SeekForwardReleased'
E_SEEK_BACK='E_SeekBack'
E_SEEK_BACK_RELEASED='E_SeekBackReleased'
E_MIDI_DETECTED='E_MIDIDetected'
E_MIDI_PAUSED='E_MIDIPaused'
# Switch 'Gadget' between MIDI and Mass Storage
E_SWITCH_MODE='E_SwitchMode'
E_SWITCH_MODE_RELEASED='E_SwitchModeReleased'
E_CONFIG_COMPLETE='E_ConfigComplete'
E_CONTINUOUS_PLAYBACK_ENABLE='E_ContinuousPlaybackEnable'
E_CONTINUOUS_PLAYBACK_DISABLE='E_ContinuousPlaybackDisable'
E_TRACKING_SILENCE_ENABLE='E_TrackingSilenceEnable'
E_TRACKING_SILENCE_DISABLE='E_TrackingSilenceDisable'
E_MASS_STORAGE_DISABLE='E_MassStorageDisable'
E_MASS_STORAGE_DISABLED='E_MassStorageDisabled'
E_MASS_STORAGE_DISABLED_FROM_AUTORECORD='E_MassStorageDisabledFromAutorecord'
E_ERROR='E_Error'
E_ERROR_CLEARED='E_ErrorCleared'

#
# This table maps characters that can be typed
# on a keyboard to events generated by button presses
# or events that are derived by button presses.
event_map ={
    'p' : E_PLAY_PAUSE_BUTTON, 
    'r' : E_RECORD_BUTTON,
    's' : E_STOP_BUTTON,
    'b' : E_BACK_BUTTON,
    'f' : E_FORWARD_BUTTON,
    'a' : E_AUTO_RECORD_BUTTON,
    'B' : E_SKIP_BACK,
    'F' : E_SKIP_FORWARD,
    '{' : E_SEEK_BACK,
    '}' : E_SEEK_FORWARD,
    '[' : E_SEEK_BACK_RELEASED,
    ']' : E_SEEK_FORWARD_RELEASED,
    'X' : E_SWITCH_MODE,
    'x' : E_SWITCH_MODE_RELEASED,
    'C' : E_CONTINUOUS_PLAYBACK_ENABLE,
    'c' : E_CONTINUOUS_PLAYBACK_DISABLE,
    'T' : E_TRACKING_SILENCE_ENABLE,
    't' : E_TRACKING_SILENCE_DISABLE
    }

characters_that_can_repeat = {
    'b', 'f', 's'
    }

held_character_translation_map = {
    'b' : '{',
    'f' : '}',
    's' : 'X',
    'x' : 'X'
    }

held_character_release_map = {
     'b' : '[',
    'f' : ']',
    # No release character for 's'
    's' : ' '
    }

non_held_character_translation_map = {
    'b' : 'B',
    'f' : 'F',
    's' : 's'  
    }

#
# These are all of the states related to interactions
# with the Elephant transport
#
S_READY='ElephantReady'
S_PLAYING='Playing'
S_PLAYING_PAUSED='PlayingPaused'
S_RECORDING='Recording'
S_RECORDING_PAUSED='RecordingPaused'
S_SAVING_RECORDING='SavingRecording'
S_SKIP_BACK_WHILE_STOPPED='SkipBackWhileStopped'
S_SKIP_FORWARD_WHILE_STOPPED='SkipForwardWhileStopped'
S_SKIP_BACK_WHILE_PLAYING='SkipBackWhilePlaying'
S_SKIP_FORWARD_WHILE_PLAYING_PAUSED='SkipForwardWhilePlayingPaused'
S_SKIP_BACK_WHILE_PLAYING_PAUSED='SkipBackWhilePlayingPaused'
S_SKIP_FORWARD_WHILE_PLAYING='SkipForwardWhilePlaying'
S_SEEKING_FORWARD='SeekingForward'
S_SEEKING_BACK='SeekingBack'
S_WAITING_FOR_MIDI='WaitingForMIDI'
S_AUTO_RECORDING='RecordingAuto'
S_AUTO_SAVING='SavingAuto'
S_MASS_STORAGE_ENABLED='MassStorageEnabled'
S_MASS_STORAGE_DISABLING='MassStorage Disabling'
S_CONTINUOUS_PLAYBACK_ENABLE='ContinuousEnabledPlayback'
S_CONTINUOUS_PLAYBACK_DISABLE='ContinuousDisabledPlayback'
S_TRACKING_SILENCE_ENABLE='TrackingSilenceEnable'
S_TRACKING_SILENCE_DISABLE='TrackingSilenceDisable'
S_MIDI_ERROR='MIDIError'
S_ELEPHANT_ERROR='ElephantError'
S_ELEPHANT_ONLINE='ElephantOnline'
S_CLIENT_CONNECTED='ClientConnected'
S_ANY='*'

class ElephantStates(Enum):
    S_READY = 'ElephantReady'
    S_PLAYING = 'Playing'
    S_PLAYING_PAUSED = 'PlayingPaused'
    S_RECORDING = 'Recording'
    S_RECORDING_PAUSED = 'RecordingPaused'
    S_SAVING_RECORDING = 'SavingRecording'
    S_SKIP_BACK_WHILE_STOPPED = 'SkipBackWhileStopped'
    S_SKIP_FORWARD_WHILE_STOPPED = 'SkipForwardWhileStopped'
    S_SKIP_BACK_WHILE_PLAYING = 'SkipBackWhilePlaying'
    S_SKIP_FORWARD_WHILE_PLAYING_PAUSED = 'SkipForwardWhilePlayingPaused'
    S_SKIP_BACK_WHILE_PLAYING_PAUSED = 'SkipBackWhilePlayingPaused'
    S_SKIP_FORWARD_WHILE_PLAYING = 'SkipForwardWhilePlaying'
    S_SEEKING_FORWARD = 'SeekingForward'
    S_SEEKING_BACK = 'SeekingBack'
    S_WAITING_FOR_MIDI = 'WaitingForMIDI'
    S_AUTO_RECORDING = 'RecordingAuto'
    S_AUTO_SAVING = 'SavingAuto'
    S_MASS_STORAGE_ENABLED = 'MassStorageEnabled'
    S_MASS_STORAGE_DISABLING = 'MassStorage Disabling'
    S_CONTINUOUS_PLAYBACK_ENABLE = 'ContinuousEnabledPlayback'
    S_CONTINUOUS_PLAYBACK_DISABLE = 'ContinuousDisabledPlayback'
    S_TRACKING_SILENCE_ENABLE = 'TrackingSilenceEnable'
    S_TRACKING_SILENCE_DISABLE = 'TrackingSilenceDisable'
    S_MIDI_ERROR = 'MIDIError'
    S_ELEPHANT_ERROR = 'ElephantError'
    S_ELEPHANT_ONLINE = 'ElephantOnline'
    S_CLIENT_CONNECTED = 'ClientConnected'
    S_ANY = '*'
    
    def getState(self, state):
        return repr(state)
    
    def genDartPlayerStateEnum(self):
        print('enum PlayerState {')
        numberOfStates=len(ElephantStates)
        stateNumber=0
        for name, member in ElephantStates.__members__.items():
            stateNumber+=1
            if stateNumber < numberOfStates :
                print(f"    {name},")
            else:
                print(f"    {name}")
                print("}")
           

def is_channel_message(msg):
    return (msg.type in midi_channel_messages.keys())

midi_channel_messages = {
    'note_off' : 'channel note velocity',
    'note_on' : 'channel note velocity',
    'polytouch' : 'channel note value',
    'control_change' : 'channel control value',
    'program_change' : 'channel program',
    'aftertouch' : 'channel value',
    'pitchwheel' : 'channel pitch'
}
    


