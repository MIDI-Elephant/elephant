
#
# Some configuration values
#
MAX_MIDI_IDLE_TIME_SECONDS=10

#
# The following are the events generated by
# button presses.
#
E_PLAY_PAUSE_BUTTON='E_PlayPauseButton'
E_RECORD_BUTTON='E_RecordButton'
E_STOP_BUTTON='E_StopButton'
E_BACK_BUTTON='E_BackButton'
E_FORWARD_BUTTON='E_NextButton'
E_AUTO_RECORD_BUTTON='E_AutoRecordButton'

# 
# The following events are generated by internal code
#
E_RECORDING_SAVED='E_RecordingSaved'
E_END_OF_FILE='E_EndOfFile'
E_AUTO_NEXT='E_AutoNext'
E_NO_FILE='E_NoFile'
E_LAST_FILE='E_LastFile'
E_FIRST_FILE='E_FirstFile'
E_PREVIOUS_FILE='E_PreviousFile'
E_NEXT_FILE='E_NextFile'
E_SKIP_FORWARD='E_SkipForward'
E_SKIP_BACK='E_SkipBack'
E_SEEK_FORWARD='E_SeekForward'
E_SEEK_FORWARD_RELEASED='E_SeekForwardReleased'
E_SEEK_BACK='E_SeekBack'
E_SEEK_BACK_RELEASED='E_SeekBackReleased'
E_MIDI_DETECTED='E_MIDIDetected'
E_MIDI_PAUSED='E_MIDIPaused'
# Switch 'Gadget' between MIDI and Mass Storage
E_SWITCH_MODE='E_SwitchMode'
E_SWITCH_MODE_RELEASED='E_SwitchModeReleased'
E_CONFIG_COMPLETE='E_ConfigComplete'
E_CONTINUOUS_PLAYBACK_ENABLE='E_ContinuousPlaybackEnable'
E_CONTINUOUS_PLAYBACK_DISABLE='E_ContinuousPlaybackDisable'
E_TRACKING_SILENCE_ENABLE='E_TrackingSilenceEnable'
E_TRACKING_SILENCE_DISABLE='E_TrackingSilenceDisable'

#
# This table maps characters that can be typed
# on a keyboard to events generated by button presses
# or events that are derived by button presses.
event_map ={
    'p' : E_PLAY_PAUSE_BUTTON, 
    'r' : E_RECORD_BUTTON,
    's' : E_STOP_BUTTON,
    'b' : E_BACK_BUTTON,
    'f' : E_FORWARD_BUTTON,
    'a' : E_AUTO_RECORD_BUTTON,
    'B' : E_SKIP_BACK,
    'F' : E_SKIP_FORWARD,
    '{' : E_SEEK_BACK,
    '}' : E_SEEK_FORWARD,
    '[' : E_SEEK_BACK_RELEASED,
    ']' : E_SEEK_FORWARD_RELEASED,
    'X' : E_SWITCH_MODE,
    'x' : E_SWITCH_MODE_RELEASED,
    'C' : E_CONTINUOUS_PLAYBACK_ENABLE,
    'c' : E_CONTINUOUS_PLAYBACK_DISABLE,
    'T' : E_TRACKING_SILENCE_ENABLE,
    't' : E_TRACKING_SILENCE_DISABLE
    }

characters_that_can_repeat = {
    'b', 'f', 's'
    }

held_character_translation_map = {
    'b' : '{',
    'f' : '}',
    's' : 'X',
    'x' : 'X'
    }

held_character_release_map = {
     'b' : '[',
    'f' : ']',
    # No release character for 's'
    's' : ' '
    }

non_held_character_translation_map = {
    'b' : 'B',
    'f' : 'F',
    's' : 's'  
    }

#
# These are all of the states related to interactions
# with the Elephant transport
#
S_STOPPED='ElephantReady!'
S_PLAYING='Playing'
S_PLAYING_PAUSED='PlayingPaused'
S_RECORDING='Recording'
S_RECORDING_PAUSED='RecordingPaused'
S_SAVING_RECORDING='SavingRecording'
S_SKIP_BACK_WHILE_STOPPED='SkipBack WhileStopped'
S_SKIP_FORWARD_WHILE_STOPPED='SkipForward WhileStopped'
S_SKIP_BACK_WHILE_PLAYING='SkipBack WhilePlaying'
S_SKIP_FORWARD_WHILE_PLAYING_PAUSED='SkipForward WhilePlayingPaused'
S_SKIP_BACK_WHILE_PLAYING_PAUSED='SkipBack WhilePlayingPaused'
S_SKIP_FORWARD_WHILE_PLAYING='SkipForward WhilePlaying'
S_SEEKING_FORWARD='SeekingForward'
S_SEEKING_BACK='SeekingBack'
S_WAITING_FOR_MIDI='WaitingForMIDI'
S_AUTO_RECORDING='Recording Auto'
S_AUTO_SAVING='Saving Auto'
S_MASS_STORAGE_MANAGEMENT='MassStorage Management'
S_CONTINUOUS_PLAYBACK_ENABLE='ContinuousEnabled Playback'
S_CONTINUOUS_PLAYBACK_DISABLE='ContinuousDisabled Playback'
S_TRACKING_SILENCE_ENABLE='TrackingSilenceEnable'
S_TRACKING_SILENCE_DISABLE='TrackingSilenceDisable'

def is_channel_message(msg):
    return (msg.type in midi_channel_messages.keys())

midi_channel_messages = {
    'note_off' : 'channel note velocity',
    'note_on' : 'channel note velocity',
    'polytouch' : 'channel note value',
    'control_change' : 'channel control value',
    'program_change' : 'channel program',
    'aftertouch' : 'channel value',
    'pitchwheel' : 'channel pitch'
}


